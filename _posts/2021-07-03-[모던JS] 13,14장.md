# 13장 스코프

식별자가 유효한 범위

JS엔진이 식별자를 검색할때 사용하는 규칙

네임 스페이스 역할

### 식별자가 유효한 범위?

쉽게 말해, 모든 식별자는 선언된 위치에서 다른 코드가 자신을 참조할수 있는 유효범위가 결정된다 (생명주기랑 비슷하지만 다름)

JS에서는 전역범위, 지역범위가 있는데 지역범위는 무조건 함수의 코드블록만 인정한다(if,for이런거 x)

### 식별자 검색 규칙?

중복된 식별자가 있을때 무엇을 먼저 가르켜야 할까? 할때 사용됨

지역범위에서 지역변수와 전역변수가 똑같은 식별자 네임을 가지고 있다면. 해당 지역범위에서 지역변수를 참조 한다. (뒤에서 스코프 체인 배우고 정확히 말하자)

### 네임스페이스?

쉽게 말해, 다른 함수에 선언한 변수는 같은 이름을 가지고 있어도, 스코프가 다른 별개의 변수이다.

이는 전역범위와 지역범위끼리도 똑같음

---

## 스코프의 종류

- 전역범위 - 전역변수 - 코드 전체
- 지역범위 - 지역변수 - 함수 몸체(내부)

### 전역변수?

전역범위에서 (= 함수가 아닌곳에서) 정의된 변수이다. 어디서든 참조 할수 있다.

### 지역변수?

지역범위에서 (=함수 내부) 정의된 변수이다. 함수 내부에서 만 참조 가능하고, 함수 내부에 하위지역(중첩함수) 가 있으면 하위 지역 범위에서도 스코프가 유효하다.

쉽게 말해, 왕의 명령(=변수)은 신하 에게도 영향이 있고 되고, 신하가 거느리고 있는 노예 에도 영향이 있다.

이러한 계층 연결을 스코프 체인이라 한다.

### 스코프 체인?

스코프가 함수의 중첩에 의해 계층 구조를 가지고 있는것.

JS엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프 에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

쉽게 말해, 왕에게도 돈이 있고, 신하에게도 돈이 있고, 노예에게도 돈이 있다 하자. 노예에게 돈을 달라 했을때. 노예에게 돈이 있으면  노예 돈을 가져 간다. 왕, 신하 한테 있어도. 하지만 노예에게 돈이 없다 하면, 신하에게 달라 하고. 신하도 없으면 왕에게 달라한다.

즉, 상위 스코프에서 유효한 변수는 → 하위에서도 유효함 , 하지만 하위에서 이미 유효한 변수는 상위 스코프에서 참조 할 수 없다는것.

```jsx
function foo() {
    console.log('foo');;
}

function boo() {
    function foo() {
        console.log('boo - foo');
    }
    foo();
}
boo(); // boo에는 함수 foo가 이미 있으니. foo();는 boo에 있는 foo를 먼저 호출한다.
```

---

## 함수 레벨 스코프

코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.

---

## 렉시컬 스코프

함수를 어디서 정의 했는지에 따라 상위 스코프를 정하는것

```jsx
var x = 1;
function foo() {
    var x = 10;
    bar();
}

function bar() {
    console.log(x);
}
foo(); // 1
bar(); // 1
```

JS스코프 체인을 생각하면이해하기 편하다. 계층형 구조를 foo와 boo는 계층형 구조로 이루어져 있다. 

foo가 호출 되었을때. foo는 bar를 호출한다. 그렇담 bar함수를 보자면 x를 참조한다. 

여기서! 만약 함수 호출이 되었을때, 호출된 위치에서 상위 스코프를 결정한다면 ⇒ 동적 스코프

하지만 렉시컬 스코프는 정적 스코프이다.

즉, 함수의 범위는 호출이 아닌, 정의 이다. 결국 bar가 정의된 곳은 bar는 전체 범위 안에 있는 한 지역 범위이다.(중첩이 아니다.) 그래서 bar안에 있는 x는 bar 함수에 없기때문에 상위 스코프로 가고, 상위 스코프는 전역 범위이기때문에 1이된다. foo에서 호출한 bar또한 그렇다.

---

---

# 14장 전역변수의 문제점

앞서 생명 주기를 먼저 보자

### 전역변수의 생명주기 vs 지역변수의 생명주기

- 전역변수 : 전체 객체의 생명 주기와 일치
- 지역변수 : 함수가 시작되면서 호이스팅과 함께 시작해, 참조가 다 끝나면 = 함수의 생명주기

    (가끔 함수 끝나도 참조 하고 있을수 있다)

### 지역변수의  함수 호이스팅?

JS의 호이스팅 처럼 호출 이후. 함수 코드가 순차적으로 런타임 되기전 함수 내부에 있는 변수들은 호이스팅 된다.

### 전역변수의 문제점

- 암묵적 결합 허용 = 모든 코드가 전역 변수를 참조하고 변경 할수 있음
- 긴 생명주기 = 메모리 자원도 오래 먹음
- 스코프 체인상 종점 = 전역변수에 대한 검색이 가장 오래 걸림. (노예에게 왕관 달라 하면, 왕까지 다 가야함)
- 네임스페이스 오염 = JS는 네임 스페이스 가 없어서. 전역 스코프를 공유 한다.

### 전역변수 사용 억제 하는 방법

- 즉시 실행함수 사용하기 : 실행하고 끝나서 스코프 정해짐
- 네임스페이스 객체: 네임스페이스 역할을 할 변수를 정하고. 그거를 활용해 변수 할당
- 모듈 패턴 (나중에)
- ES6 모듈 (나중에)