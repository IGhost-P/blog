## 5장 표현식과 문

### 값이란?

표현식이 평가되어 생선된 결과

*평가: 식을 해석해서 값을 생성하거나 참조하는것을 의미한다.

10 + 20; // 30(값) = 10+20(평가항목)은 평가 되어 30(평가)을 생성한다.

이와 마찬 가지로 **변수**는 **하나의 값**을 저장하기 위해 확보한 **메모리 공간 자체**, **메모리 공간**을 식별하기 위해 붙인 이름

var sum = 10 + 20; 에서 sum은 10+20이 아니라 평가된 30(값) 을 할당받는다.

### 리터럴이란?

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.

[리터럴 종류](https://www.notion.so/f499cecf6149419ca80869b045ecf2de)

쉽게 말해 이렇게 안쓰면 오류남 프로그램이 못알아 먹음.

### 표현식이란?

값으로 평가될 수 있는 문(문장), 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

var score = 100; // 100은 정수 리터럴로 평가 된다. 고로 표현식이다.

score; // score이란 식별자를 참조하면 변수 값 100으로 평가 된다 값은 생성은 x하지만 평가는 o 고로 표현식이다. 

표현식은 값으로 평가된다. 그리고 표현식과 표현식이 평가된 값은 동등한 관계이다.

1 + 2 (표현식) =  3(평가된 값)

이것으로  문법적으로 값이 위치하는 자리에 표현식이 위치 할수 있다는 것을 알수 있다.

1+2 = 3 이나 , 3 = 1 + 2 똑같다 // x = 를 3이라 한다면, x(표현식)+4 이나 3(평가된값)+4 나 똑같다 

### 문이란?

프로그램을 구성하는 기본 단위 이자 최소 실행 단위이다.(=명령문)

### 토큰이란?

문법적인 의미를 가지며, 문법적으로 더이상 나눌수 없는 기본 요소를 말한다.

var(토큰) sum(토큰) =(토큰) 1(토큰) + 2(토큰);(토큰 ) = 문이다.

문의 종류

- 선언문:  var x;
- 할당문: x = 5;
- 함수 선언문: fuction foo() {} or const(let) foo = function(){}
- 조건문: if(x > 1){console.log(x);}
- 반복문: for(var i = 0; i<2; i++){console.log(i);}

### 세미콜론과 세미콜론 자동삽입 구문

세미콜론은 문의 종료를 나타 낸다.

단, 중괄호로 묶은 코드 블록 = {} 은 붙이지 않는다.

이 코드블록은 언제나 문의 종료를 의마하는 자체 종결성을 가지기 때문이다.

JS엔진은 세미콜론을 자동 삽입 기능(ASI)가 있어서 세미콜론이 생략 가능하다.

하지만 개발자의 의도와 다를수도있다. 

그러니 걍 붙히자.

### 표현식인 문과 아닌 문

표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.

표현식이 아닌문

var foo(표현식) = var x (할당문이지만 값이 아님 = 평가되지 않음.)

 표현식인문

 var foo(표현식) = x(표현식) = 100(값) (x란 할당문은 100이라는 값으로 평가된다, 따라서 foo또한 100으로 평가 된다.)

---

## 6장 데이터 표현

데이터 타입이란 값의 종류이다.

**크게 원시 타입 | 객체 타입으로 분류 한다**

[JS에서 제공하는 7개 타입](https://www.notion.so/0e0ceef47b934d62931a73e72caac891)

### 숫자 타입

모든 수를 실수로 처리하며, 정수만 표현하기 위한 별도의 데이터 타입이 존재하지 않는다.

숫자타입의 추가적인 요소

- 양의 무한대 : 10 / 0
- 음의 무한대 : 10 / -1
- NaN 산술연산 불가 : 대소문자 구별함

### 문자열 타입

텍스트 데이터를 나타내는데 사용함.

나타내는 방법

- ''
- ""
- ``(템플릿 리터럴)

string = '이현수는 "잘생겼다"' 랑 '이현수는''잘생겼다'는 다르다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae595794-889a-4361-848c-65a44e337718/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae595794-889a-4361-848c-65a44e337718/Untitled.png)

### 템플릿 리터럴

ES6에 도입된 새로운 문자열 표기법

``을 사용함

### 멀티라인 문자열

일반 문자열 내에서는 줄바꿈이 허용되지 않음.

그래서 이스케이프 시퀀스를 사용해야함.

[이스케이프 시퀀스 종류](https://www.notion.so/09b2062c541c4fe0a290f8d9488a8b74)

- 예시

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/940cbeeb-6c43-4bcd-be5a-df72c31fd025/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/940cbeeb-6c43-4bcd-be5a-df72c31fd025/Untitled.png)

### 표현식의 삽입

문자열은 문자열 연산자 +를 사용해 연결할수 있다.

console.log('이현수는 ' +'x'+' 잘생겼다'); (x를 '개'라 하면), = '이현수는 개 잘생겼다'

console.log(`이현수는 ${x} 잘생겼다`) ``에서만 가능한 ${} 삽입이다.

### 불리언 타입

참(true) 와 거짓(false) 이다.

### undefined 타입

uedefined 즉 아직 할당하지않은, 정의되지 않은 값이다.

*변수 값이 없다는것을 알리고 싶다면 undefined가 아닌, null을 사용해야한다.

### null 타입

- 선언: 변수가 없다는것을 의도적으로 명시 null을 선언한다.
- 반환: 함수가 유효한 값을 반환 할수 없는 경우에 null을 반환한다.

### 심벌 타입

변경 불가능한 원시 타입, 다른 값과 중복되지 않은 유일무이한 값

심벌값을 할당할때, Symbol() 함수를 사용해야한다.

- 33장에서 정확히 다뤄볼것

### 객체 타입

자바스크립트는 객체 기반 언어 = **자바스크립트를 이루고 있는 거의 모든 것들이 객체**

- 11장에서 자세하게 다뤄볼것

## 그렇담 이러한 데이터 타입의 필요성은 무엇일까?

값을 메모리에 저장하고 참조할때, 메모리 공간의 낭비와 손실없이 값을 저장, 참조,'**해석** '하기 위해서

var score = 65; // 여기에 값 65을 저장하기 위해 메모리 공간을 확보해야한다. 

여기서 자바스크립트 엔진은 값의 데이터 타입의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.

65은 숫자 타입이고 숫자 값의 크기를 8 바이트로 지정했기 때문에(자바 스크립트 엔지 제조사가 숫자 타입을 8비트로 지정했다 하면) 8바이트 공간을 확보한다.

그렇다면 console.log(score); 를 할때 자바 스크립트 엔진은 몇바이트씩 읽어야하는지 어떻게 알까?

일단 score는 식별자 이니깐 매핑 관계를 통해 65이 할당된것을 알수있고, 65은 숫자 타입으로 자바스크립트 엔진은 score 변수를 숫자 타입으로 인식한다, 그래서 8바이트씩 읽어 온다.

그럼 읽어온 숫자 65(0100 0001)가 이게 문자열 A 인지 숫자 65인지 어떻게 알까?

자바스크립트 엔진은 score를 참조해서 0100 0001 를 가지고 왔기 때문에 숫자로 해석한다.

## 동적 타이핑이란?

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 된다.(데이터 추론)

그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할수 있다.

**이게뭔 개소리냐면**

C언어 처럼 처음에 데이터 타입을 처음부터 지정(int x는 계속 int타입)해야하지만

JS는 선언 한뒤부터는 할당된 값에 따라 데이터 타입이 바뀜 (var x; 하고 난뒤 x=1이면 숫자 타입 → x='현수'로 바꾸면 자동적으로 문자 타입 으로 바뀜)

이렇게 하면 편하긴 하지만

- 변수 값 추적하기 어려움
- 변수 값 타입을 확신하기 어려움
- 개발자의 의도랑 달라짐

즉, 유연하지만 신뢰성은 떨어진다.

따라서 그나마 안정적이게 코드를 만들라고 하면

1. 변수는 꼭 필요한 경우에만 쓴다. 

    why? 변수가 많으면 개발자의 의도와 JS엔진 의도와 다릴 경우의 수를 높힌다.

2. 변수는 유효범위(스코프)를 좁게 만들어 부작용을 억제해야한다.

    why? 변수의 유효범위거 넓으면 오류 확률이 높대 (13장에서 알아봄)

3. 전역 변수는 최대한 쓰지 말자.

    why? 어디서든 참조/변경이 가능하니깐 의도하지 않게 참조/변경될 가능성이 높다

4. 변수(var, let)보다는 상수(const)를 사용해 변경을 억제하자.
5. 변수(모든 식별자들) 이름은 목적이나, 의미를 알수있게 네이밍하자

    why? 협업할때 한 헷갈림.

### 잊지말아야하는건

코드는 가독성이 좋아야한다.